{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null;\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set();\n  const inputNodeNames = new Set(Object.keys(inputs).map(name => parseNodeName(name)[0]));\n  initNodes = initNodes || [];\n  const initNodeNames = new Set(initNodes.map(node => parseNodeName(node.name)[0]));\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes || [];\n  const isUsed = node => usedNodes.has(typeof node === 'string' ? node : node.name);\n  function unique(nodes) {\n    return [...new Map(nodes.map(node => [node.name, node])).values()];\n  }\n  const predefinedNodes = unique([...inputNodes, ...graph.weights, ...initNodes]).filter(isUsed);\n  const allNodes = unique([...predefinedNodes, ...Object.values(graph.nodes)]).filter(isUsed);\n  const nameToNode = new Map(allNodes.map(node => [node.name, node]));\n  const inCounts = {};\n  for (const node of allNodes) {\n    inCounts[node.name] = inCounts[node.name] || 0;\n    for (const child of node.children) {\n      // When the child is unused, set in counts to infinity so that it will\n      // never be decreased to 0 and added to the execution list.\n      if (!isUsed(child)) {\n        inCounts[child.name] = Number.POSITIVE_INFINITY;\n      }\n      inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n    }\n  }\n  // Build execution order for all used nodes regardless whether they are\n  // predefined or not.\n  const frontier = Object.entries(inCounts).filter(([, inCount]) => inCount === 0).map(([name]) => name);\n  const orderedNodeNames = [...frontier];\n  while (frontier.length > 0) {\n    const nodeName = frontier.pop();\n    const node = nameToNode.get(nodeName);\n    for (const child of node.children.filter(isUsed)) {\n      if (--inCounts[child.name] === 0) {\n        orderedNodeNames.push(child.name);\n        frontier.push(child.name);\n      }\n    }\n  }\n  const orderedNodes = orderedNodeNames.map(name => nameToNode.get(name));\n  const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n  return filteredOrderedNodes;\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {\n  const nameToNode = new Map(orderedNodes.map(node => [node.name, node]));\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  const stack = predefinedNodes.map(node => node.name);\n  const predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    const nodeName = stack.pop();\n    const node = nameToNode.get(nodeName);\n    for (const child of node.children) {\n      if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {\n        continue;\n      }\n      predefinedReachableNodeNames.add(child.name);\n      stack.push(child.name);\n    }\n  }\n  // Filter out unreachable nodes and build the ordered node list.\n  const filteredOrderedNodes = orderedNodes.filter(node => predefinedReachableNodeNames.has(node.name));\n  return filteredOrderedNodes;\n}\nclass NodesExecutionOrderError extends Error {\n  constructor(message) {\n    super(`NodesExecutionOrderError: ${message}`);\n  }\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(orderedNodes, predefinedNodes) {\n  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n  const predefinedNodeNames = new Set(predefinedNodes.map(node => node.name));\n  const isPredefined = node => predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  const willBeExecutedNodeNames = new Set(orderedNodes.map(node => node.name));\n  const willBeExecuted = node => willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n  for (const node of orderedNodes) {\n    for (const child of node.children.filter(willBeExecuted)) {\n      if (!nodeNameToOrder.has(child.name)) {\n        throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);\n      }\n      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n        throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);\n      }\n    }\n    if (!isPredefined(node)) {\n      for (const input of node.inputs) {\n        if (!nodeNameToOrder.has(input.name)) {\n          throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);\n        }\n        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n          throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);\n        }\n      }\n    }\n  }\n}\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes) {\n  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n  const INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n  const getSelfLifeSpan = node => {\n    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n    return node.children.map(getSelfLifeSpan).reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n  });\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  const liveUntilMap = new Map();\n  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    const liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    const node = orderedNodes[nodeOrder];\n    const liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name).push(node);\n  }\n  return liveUntilMap;\n}\nconst CONTROL_FLOW_OPS = new Set(['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While']);\nconst DYNAMIC_SHAPE_OPS = new Set(['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where']);\nconst HASH_TABLE_OPS = new Set(['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2']);\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.has(node.op);\n}","map":null,"metadata":{},"sourceType":"module"}