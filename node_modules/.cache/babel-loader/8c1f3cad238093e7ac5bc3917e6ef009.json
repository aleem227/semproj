{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { isPromise } from './util_base';\n// Expects flags from URL in the format ?tfjsflags=FLAG1:1,FLAG2:true.\nconst TENSORFLOWJS_FLAGS_PREFIX = 'tfjsflags';\n/**\n * The environment contains evaluated flags as well as the registered platform.\n * This is always used as a global singleton and can be retrieved with\n * `tf.env()`.\n *\n * @doc {heading: 'Environment'}\n */\nexport class Environment {\n  // tslint:disable-next-line: no-any\n  constructor(global) {\n    this.global = global;\n    this.flags = {};\n    this.flagRegistry = {};\n    this.urlFlags = {};\n    // Jasmine spies on this in 'environment_test.ts'\n    this.getQueryParams = getQueryParams;\n    this.populateURLFlags();\n  }\n  setPlatform(platformName, platform) {\n    if (this.platform != null) {\n      if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {\n        console.warn(`Platform ${this.platformName} has already been set. ` + `Overwriting the platform with ${platformName}.`);\n      }\n    }\n    this.platformName = platformName;\n    this.platform = platform;\n  }\n  registerFlag(flagName, evaluationFn, setHook) {\n    this.flagRegistry[flagName] = {\n      evaluationFn,\n      setHook\n    };\n    // Override the flag value from the URL. This has to happen here because\n    // the environment is initialized before flags get registered.\n    if (this.urlFlags[flagName] != null) {\n      const flagValue = this.urlFlags[flagName];\n      if (!(env().getBool('IS_TEST') || env().getBool('PROD'))) {\n        console.warn(`Setting feature override from URL ${flagName}: ${flagValue}.`);\n      }\n      this.set(flagName, flagValue);\n    }\n  }\n  async getAsync(flagName) {\n    if (flagName in this.flags) {\n      return this.flags[flagName];\n    }\n    this.flags[flagName] = await this.evaluateFlag(flagName);\n    return this.flags[flagName];\n  }\n  get(flagName) {\n    if (flagName in this.flags) {\n      return this.flags[flagName];\n    }\n    const flagValue = this.evaluateFlag(flagName);\n    if (isPromise(flagValue)) {\n      throw new Error(`Flag ${flagName} cannot be synchronously evaluated. ` + `Please use getAsync() instead.`);\n    }\n    this.flags[flagName] = flagValue;\n    return this.flags[flagName];\n  }\n  getNumber(flagName) {\n    return this.get(flagName);\n  }\n  getBool(flagName) {\n    return this.get(flagName);\n  }\n  getString(flagName) {\n    return this.get(flagName);\n  }\n  getFlags() {\n    return this.flags;\n  }\n  // For backwards compatibility.\n  get features() {\n    return this.flags;\n  }\n  set(flagName, value) {\n    if (this.flagRegistry[flagName] == null) {\n      throw new Error(`Cannot set flag ${flagName} as it has not been registered.`);\n    }\n    this.flags[flagName] = value;\n    if (this.flagRegistry[flagName].setHook != null) {\n      this.flagRegistry[flagName].setHook(value);\n    }\n  }\n  evaluateFlag(flagName) {\n    if (this.flagRegistry[flagName] == null) {\n      throw new Error(`Cannot evaluate flag '${flagName}': no evaluation function found.`);\n    }\n    return this.flagRegistry[flagName].evaluationFn();\n  }\n  setFlags(flags) {\n    this.flags = Object.assign({}, flags);\n  }\n  reset() {\n    this.flags = {};\n    this.urlFlags = {};\n    this.populateURLFlags();\n  }\n  populateURLFlags() {\n    if (typeof this.global === 'undefined' || typeof this.global.location === 'undefined' || typeof this.global.location.search === 'undefined') {\n      return;\n    }\n    const urlParams = this.getQueryParams(this.global.location.search);\n    if (TENSORFLOWJS_FLAGS_PREFIX in urlParams) {\n      const keyValues = urlParams[TENSORFLOWJS_FLAGS_PREFIX].split(',');\n      keyValues.forEach(keyValue => {\n        const [key, value] = keyValue.split(':');\n        this.urlFlags[key] = parseValue(key, value);\n      });\n    }\n  }\n}\nexport function getQueryParams(queryString) {\n  const params = {};\n  queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, (s, ...t) => {\n    decodeParam(params, t[0], t[1]);\n    return t.join('=');\n  });\n  return params;\n}\nfunction decodeParam(params, name, value) {\n  params[decodeURIComponent(name)] = decodeURIComponent(value || '');\n}\nfunction parseValue(flagName, value) {\n  const lowerCaseValue = value.toLowerCase();\n  if (lowerCaseValue === 'true' || lowerCaseValue === 'false') {\n    return lowerCaseValue === 'true';\n  } else if (`${+lowerCaseValue}` === lowerCaseValue) {\n    return +lowerCaseValue;\n  } else {\n    return value;\n  }\n}\n/**\n * Returns the current environment (a global singleton).\n *\n * The environment object contains the evaluated feature values as well as the\n * active platform.\n *\n * @doc {heading: 'Environment'}\n */\nexport function env() {\n  return ENV;\n}\nexport let ENV = null;\nexport function setEnvironmentGlobal(environment) {\n  ENV = environment;\n}","map":null,"metadata":{},"sourceType":"module"}