{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization, unstack, stack, tensor, tidy, range, image } from '@tensorflow/tfjs-core';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../../utils/types_utils';\nimport { Layer } from '../../engine/topology';\nimport * as K from '../../backend/tfjs_backend';\nconst {\n  resizeBilinear,\n  cropAndResize\n} = image;\nclass CenterCrop extends Layer {\n  constructor(args) {\n    super(args);\n    this.height = args.height;\n    this.width = args.width;\n  }\n  centerCrop(inputs, hBuffer, wBuffer, height, width, inputHeight, inputWidth, dtype) {\n    return tidy(() => {\n      let input;\n      let isRank3 = false;\n      const top = hBuffer / inputHeight;\n      const left = wBuffer / inputWidth;\n      const bottom = (height + hBuffer) / inputHeight;\n      const right = (width + wBuffer) / inputWidth;\n      const bound = [top, left, bottom, right];\n      const boxesArr = [];\n      if (inputs.rank === 3) {\n        isRank3 = true;\n        input = stack([inputs]);\n      } else {\n        input = inputs;\n      }\n      for (let i = 0; i < input.shape[0]; i++) {\n        boxesArr.push(bound);\n      }\n      const boxes = tensor(boxesArr, [boxesArr.length, 4]);\n      const boxInd = range(0, boxesArr.length, 1, 'int32');\n      const cropSize = [height, width];\n      const cropped = cropAndResize(input, boxes, boxInd, cropSize, 'nearest');\n      if (isRank3) {\n        return K.cast(getExactlyOneTensor(unstack(cropped)), dtype);\n      }\n      return K.cast(cropped, dtype);\n    });\n  }\n  upsize(inputs, height, width, dtype) {\n    return tidy(() => {\n      const outputs = resizeBilinear(inputs, [height, width]);\n      return K.cast(outputs, dtype);\n    });\n  }\n  call(inputs, kwargs) {\n    return tidy(() => {\n      const rankedInputs = getExactlyOneTensor(inputs);\n      const dtype = rankedInputs.dtype;\n      const inputShape = rankedInputs.shape;\n      const inputHeight = inputShape[inputShape.length - 3];\n      const inputWidth = inputShape[inputShape.length - 2];\n      let hBuffer = 0;\n      if (inputHeight !== this.height) {\n        hBuffer = Math.floor((inputHeight - this.height) / 2);\n      }\n      let wBuffer = 0;\n      if (inputWidth !== this.width) {\n        wBuffer = Math.floor((inputWidth - this.width) / 2);\n        if (wBuffer === 0) {\n          wBuffer = 1;\n        }\n      }\n      if (hBuffer >= 0 && wBuffer >= 0) {\n        return this.centerCrop(rankedInputs, hBuffer, wBuffer, this.height, this.width, inputHeight, inputWidth, dtype);\n      } else {\n        return this.upsize(inputs, this.height, this.width, dtype);\n      }\n    });\n  }\n  getConfig() {\n    const config = {\n      'height': this.height,\n      'width': this.width\n    };\n    const baseConfig = super.getConfig();\n    Object.assign(config, baseConfig);\n    return config;\n  }\n  computeOutputShape(inputShape) {\n    inputShape = getExactlyOneShape(inputShape);\n    const hAxis = inputShape.length - 3;\n    const wAxis = inputShape.length - 2;\n    inputShape[hAxis] = this.height;\n    inputShape[wAxis] = this.width;\n    return inputShape;\n  }\n}\n/** @nocollapse */\nCenterCrop.className = 'CenterCrop';\nexport { CenterCrop };\nserialization.registerClass(CenterCrop);","map":null,"metadata":{},"sourceType":"module"}