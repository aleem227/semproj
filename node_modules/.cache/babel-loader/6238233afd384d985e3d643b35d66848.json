{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { assert } from './util';\n/**\n * Maps to mapping between the custom object and its name.\n *\n * After registering a custom class, these two maps will add key-value pairs\n * for the class object and the registered name.\n *\n * Therefore we can get the relative registered name by calling\n * getRegisteredName() function.\n *\n * For example:\n * GLOBAL_CUSTOM_OBJECT: {key=registeredName: value=corresponding\n * CustomObjectClass}\n *\n * GLOBAL_CUSTOM_NAMES: {key=CustomObjectClass: value=corresponding\n * registeredName}\n *\n */\nconst GLOBAL_CUSTOM_OBJECT = new Map();\nconst GLOBAL_CUSTOM_NAMES = new Map();\n/**\n * Serializable defines the serialization contract.\n *\n * TFJS requires serializable classes to return their className when asked\n * to avoid issues with minification.\n */\nexport class Serializable {\n  /**\n   * Return the class name for this class to use in serialization contexts.\n   *\n   * Generally speaking this will be the same thing that constructor.name\n   * would have returned.  However, the class name needs to be robust\n   * against minification for serialization/deserialization to work properly.\n   *\n   * There's also places such as initializers.VarianceScaling, where\n   * implementation details between different languages led to different\n   * class hierarchies and a non-leaf node is used for serialization purposes.\n   */\n  getClassName() {\n    return this.constructor.className;\n  }\n  /**\n   * Creates an instance of T from a ConfigDict.\n   *\n   * This works for most descendants of serializable.  A few need to\n   * provide special handling.\n   * @param cls A Constructor for the class to instantiate.\n   * @param config The Configuration for the object.\n   */\n  /** @nocollapse */\n  static fromConfig(cls, config) {\n    return new cls(config);\n  }\n}\n/**\n * Maps string keys to class constructors.\n *\n * Used during (de)serialization from the cross-language JSON format, which\n * requires the class name in the serialization format matches the class\n * names as used in Python, should it exist.\n */\nexport class SerializationMap {\n  constructor() {\n    this.classNameMap = {};\n  }\n  /**\n   * Returns the singleton instance of the map.\n   */\n  static getMap() {\n    if (SerializationMap.instance == null) {\n      SerializationMap.instance = new SerializationMap();\n    }\n    return SerializationMap.instance;\n  }\n  /**\n   * Registers the class as serializable.\n   */\n  static register(cls) {\n    SerializationMap.getMap().classNameMap[cls.className] = [cls, cls.fromConfig];\n  }\n}\n/**\n * Register a class with the serialization map of TensorFlow.js.\n *\n * This is often used for registering custom Layers, so they can be\n * serialized and deserialized.\n *\n * Example 1. Register the class without package name and specified name.\n *\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer);\n * console.log(tf.serialization.GLOBALCUSTOMOBJECT.get(\"Custom>MyCustomLayer\"));\n * console.log(tf.serialization.GLOBALCUSTOMNAMES.get(MyCustomLayer));\n * ```\n *\n * Example 2. Register the class with package name: \"Package\" and specified\n * name: \"MyLayer\".\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer, \"Package\", \"MyLayer\");\n * console.log(tf.serialization.GLOBALCUSTOMOBJECT.get(\"Package>MyLayer\"));\n * console.log(tf.serialization.GLOBALCUSTOMNAMES.get(MyCustomLayer));\n * ```\n *\n * Example 3. Register the class with specified name: \"MyLayer\".\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer, undefined, \"MyLayer\");\n * console.log(tf.serialization.GLOBALCUSTOMOBJECT.get(\"Custom>MyLayer\"));\n * console.log(tf.serialization.GLOBALCUSTOMNAMES.get(MyCustomLayer));\n * ```\n *\n * Example 4. Register the class with specified package name: \"Package\".\n * ```js\n * class MyCustomLayer extends tf.layers.Layer {\n *   static className = 'MyCustomLayer';\n *\n *   constructor(config) {\n *     super(config);\n *   }\n * }\n * tf.serialization.registerClass(MyCustomLayer, \"Package\");\n * console.log(tf.serialization.GLOBALCUSTOMOBJECT\n * .get(\"Package>MyCustomLayer\"));\n * console.log(tf.serialization.GLOBALCUSTOMNAMES\n * .get(MyCustomLayer));\n * ```\n *\n * @param cls The class to be registered. It must have a public static member\n *   called `className` defined and the value must be a non-empty string.\n * @param pkg The package name that this class belongs to. This used to define\n *     the key in GlobalCustomObject. If not defined, it defaults to `Custom`.\n * @param name The name that user specified. It defaults to the actual name of\n *     the class as specified by its static `className` property.\n * @doc {heading: 'Models', subheading: 'Serialization', ignoreCI: true}\n */\nexport function registerClass(cls, pkg, name) {\n  assert(cls.className != null, () => `Class being registered does not have the static className ` + `property defined.`);\n  assert(typeof cls.className === 'string', () => `className is required to be a string, but got type ` + typeof cls.className);\n  assert(cls.className.length > 0, () => `Class being registered has an empty-string as its className, ` + `which is disallowed.`);\n  if (typeof pkg === 'undefined') {\n    pkg = 'Custom';\n  }\n  if (typeof name === 'undefined') {\n    name = cls.className;\n  }\n  const className = name;\n  const registerName = pkg + '>' + className;\n  SerializationMap.register(cls);\n  GLOBAL_CUSTOM_OBJECT.set(registerName, cls);\n  GLOBAL_CUSTOM_NAMES.set(cls, registerName);\n  return cls;\n}\n/**\n * Get the registered name of a class. If the class has not been registered,\n * return the class name.\n *\n * @param cls The class we want to get register name for. It must have a public\n *     static member called `className` defined.\n * @returns registered name or class name.\n */\nexport function getRegisteredName(cls) {\n  if (GLOBAL_CUSTOM_NAMES.has(cls)) {\n    return GLOBAL_CUSTOM_NAMES.get(cls);\n  } else {\n    return cls.className;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}