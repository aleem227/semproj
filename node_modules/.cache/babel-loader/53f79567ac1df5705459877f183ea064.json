{"ast":null,"code":"/**\n * @license\n * Copyright 2022 CodeSmith LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { denseBincount, mul } from '@tensorflow/tfjs-core';\nimport { getExactlyOneTensor } from '../../utils/types_utils';\nimport { expandDims } from '@tensorflow/tfjs-core';\nimport { ValueError } from '../../errors';\nimport * as K from '../../backend/tfjs_backend';\nexport function encodeCategoricalInputs(inputs, outputMode, depth, weights) {\n  let input = getExactlyOneTensor(inputs);\n  if (input.dtype !== 'int32') {\n    input = K.cast(input, 'int32');\n  }\n  if (outputMode === 'int') {\n    return input;\n  }\n  const originalShape = input.shape;\n  if (input.rank === 0) {\n    input = expandDims(input, -1);\n  }\n  if (outputMode === 'oneHot') {\n    if (input.shape[input.shape.length - 1] !== 1) {\n      input = expandDims(input, -1);\n    }\n  }\n  if (input.rank > 2) {\n    throw new ValueError(`When outputMode is not int, maximum output rank is 2` + ` Received outputMode ${outputMode} and input shape ${originalShape}` + ` which would result in output rank ${input.rank}.`);\n  }\n  const binaryOutput = ['multiHot', 'oneHot'].includes(outputMode);\n  const denseBincountInput = input;\n  let binCounts;\n  if (typeof weights !== 'undefined' && outputMode === 'count') {\n    binCounts = denseBincount(denseBincountInput, weights, depth, binaryOutput);\n  } else {\n    binCounts = denseBincount(denseBincountInput, [], depth, binaryOutput);\n  }\n  if (outputMode !== 'tfIdf') {\n    return binCounts;\n  }\n  if (weights) {\n    return mul(binCounts, weights);\n  } else {\n    throw new ValueError(`When outputMode is 'tfIdf', weights must be provided.`);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}